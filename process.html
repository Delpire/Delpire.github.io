<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Home</title>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">

    <!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap-theme.min.css">

    <!-- Starter Template -->
    <link rel="stylesheet" href="starter-template.css">

    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Chris Delpire</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li><a href="./index.html">Home</a></li>
            <li class="active"><a href="./process.html">Process</a></li>
            <li><a href="./projects.html">Projects</a></li>
            <li><a href="./quiz.html">Quiz</a></li>
            <li><a href="./hobbies.html">Hobbies</a></li>
            <li><a href="./about.html">About</a></li>
            <li><a href="./resume.pdf">Resume</a></li>
            <li><a href="./contact.html">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <div class="starter-template">
        <h1>Design Process</h1>
        <img class="img" src="process.png" height="30%" width="30%"></img>
          Rather than search the internet for design process diagrams, I decided to create my own. This way I can describe more accurately how I develop code, rather than write influenced by another model. The stages below, are how I like to develop my code.

<h3>Problem:</h3>
  
<p>Every design begins with a problem. This can be a problem in school, a task you wish you had a tool for, or simply what your boss tells you to do. Regardless of where the problem comes from, it is extremely important that this problem is well defined. For example, compare these two statements: “I need a tool to be more productive.” vs. “I need a tool to better manage my time.” The first statement is extremely broad. If I were to sit down and begin writing code to solve this, I would have a very difficult time knowing where to start. In order to begin working, I would have to dig deeper and pick a specific aspect of productivity to try to improve. The second statement is an aspect I might choose. This topic is much more manageable. I could begin developing a calendar software to organize tasks and push notifications. When I am finished with my software and present it to my client, they might say, “Well this is nice, but it wasn’t the solution I was looking for.” They might have been looking to better organize subtasks for example. This is why having a clear, well-defined problem is instrumental to producing good software.</p>

<h3>Plan:</h3>

<p>Planning is the next step to take after defining a problem. It is very easy to get excited about a problem and jump into code, but often this will prevent you from writing manageable, and scalable code. Software changes everyday along with wants and needs. My software might be able to solve my problem today, but when new problems arise, my code needs to be easy to change. For me, this involves diagramming everything out. I think about all the objects I need, the design patterns I should use for them, and how they will interact with each other. I will also examine all the logic and algorithms that will be used. This involves, writing pseudocode to get a general idea of how the algorithms will work. After all of the objects and algorithms have been physically diagrammed and written out, coding becomes very mechanical. If I jump straight into code without planning, I often run into many problems I did not foresee. This forces me to write a lot of “band-aid” code, or code that simply fixes the current error without being mindful of the rest of the software. This kind of programming is very unmanageable, and often results in more code than is necessary. Performance suffers, and if anyone else has to use my code, they will suffer as well. Planning helps prevent all of this. As mentioned above, coding is very mechanical after creating a solid plan. If a new problem arises in the code, instead of editing the code, I go back to the plan. This way I can see how that problem affects the whole solution, and when I create my fix, it will fit into the plan as a whole.</p>

<h3>Test:</h3>

<p><i>Testing? I haven’t written any software yet!</i></p>

<p>One of the things that makes software development very unique, is that tests can actually be written before code. In software, tests are pieces of code that will run your program, plugging in values and trying to break it. It is important to have your code pass all of your tests, but it is more important to write good tests. If tests are written after I write my code, I might be biased to write the test in a way that will force the test to pass. I also may make assumptions while writing the test based on what I know I have written in code. For this reason, tests are closely coupled with planning and should be written before the code. Once all the tests have been written, I can begin writing my code to pass the tests. If I know my tests are actually testing how I solve my problem rather than testing my functions, then I know the code works.</p>

<h3>Develop:</h3>

<p>Now that the tests have all been written, I can begin writing my code. As stated earlier, this step is very mechanical, and there is not much to say. This stage will involve, writing code, running tests, and then repeating. If all of the foundation has been laid out, this step is very easy.</p>

<h3>Release:</h3>

<p>When I have finished my code, it is very important to get my solution into the hands of as many people as I can. I want them to test it, try to break it, and give feedback. I am a huge fan of criticism and code reviews. These steps help me learn and improve, making the whole process easier the next time. The whole point of this process was to create a solution, and if the code never gets released then the problem was never really solved.
It is also important to make releases as often as possible. In the past, the standard was to spend all year developing software, and then pushing a release. The result was that new needs were arising faster than software was being released. The software industry is starting to adopt a new method of software development called Agile. Agile is all about short iterations and rapid releases. As problems arise, they are tackled, and the solutions are immediately made available to the software users. I believe that this is a very productive methodology that keeps the focus on the problems rather than the software, much like my design process.</p>

<h3>Support:</h3>

<p>Support is the final step in my design process, but it is by no means the least important. Even if the software is excellent, or the code is easily manageable, it is useless to consumers if there is no support around that software. This is why it is important to me to write clear, useful documentation. I make extra passes through my code to clear up my comments, and I like to create documents that contain the steps I took to design the solution. If only the code is available, then it may not be clear why I solved the problem the way I did. Writing good technical design documents, api’s and user manuals keeps my solutions alive and useful.</p>   
      </div>

      <hr>

      <footer>
        <p>Chris Delpire 2014</p>
      </footer>

    </div>    
    
  </body>
</html>